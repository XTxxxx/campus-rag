from pydantic import BaseModel, UUID4
from enum import Enum
import time
import uuid
from fastapi import HTTPException
from typing import Optional, Literal


class ChatMessage(BaseModel):
  message_id: UUID4  # Generated by uuid
  conversation_id: UUID4
  role: Literal["user", "assistant"]
  content: str
  create_time: float
  sources: Optional[list[dict[str, str]]] = None


class Conversation(BaseModel):
  conversation_id: UUID4  # Generated by uuid
  create_time: float
  update_time: float
  messages: list[ChatMessage]

  def append_message(self, message: ChatMessage):
    self.messages.append(message)
    self.update_time = time.time()


class User(BaseModel):
  user_id: str
  conversations: list[Conversation]
  create_time: float


users: list[User] = list()


class SortedBy(str, Enum):
  updated = ("updated_at",)
  created = ("created_at",)
  updated_reverse = ("-updated_at",)
  created_reverse = ("-created_at",)


class Query(BaseModel):
  user_id: str
  conversation_id: Optional[str]
  query: str


class InmemConversationManager:
  def __init__(self):
    self.users = []
    self.conversations = []

  sorted_methods = {
    SortedBy.updated: lambda x: x.update_time,
    SortedBy.created: lambda x: x.create_time,
    SortedBy.updated_reverse: lambda x: -x.update_time,
    SortedBy.created_reverse: lambda x: -x.create_time,
  }

  def get_usr_by_id(self, user_id: str) -> User:
    for user in users:
      if user.user_id == user_id:
        return user
    raise HTTPException(status_code=404, detail="User not found")

  def create_user(self, user_id: str) -> User:
    for u in users:
      if u.user_id == user_id:
        # see http://172.29.4.49/2025seiii-020-team_nailong/rag/-/issues/2
        return u  
    new_user = User(
      user_id=user_id,
      create_time=time.time(),
      conversations=[],
    )
    users.append(new_user)
    return new_user

  def get_conversations(
    self,
    user_id: str,
    first_id: int = 0,
    limit: int = 10,
    sorted_by: SortedBy = SortedBy.updated,
  ) -> list[Conversation]:
    for u in users:
      if u.user_id == user_id:
        return sorted(u.conversations, key=self.sorted_methods[sorted_by])[
          first_id : first_id + limit
        ]
    raise HTTPException(status_code=404, detail="User not found")

  def get_chat_history(self, user_id: str, conversation_id: UUID4) -> list[ChatMessage]:
    for u in users:
      if u.user_id == user_id:
        for c in u.conversations:
          if c.conversation_id == conversation_id:
            return c.messages
        raise HTTPException(status_code=404, detail="Conversation not found")
    raise HTTPException(status_code=404, detail="User not found")

  def get_converstaion_by_id(
    self, user_id: str, conversation_id: UUID4
  ) -> Conversation:
    user = self.get_usr_by_id(user_id)
    for c in user.conversations:
      if str(c.conversation_id) == conversation_id:
        return c
    raise HTTPException(status_code=404, detail="Conversation not found")

  def create_conversation(self, user_id: str):
    user = self.get_usr_by_id(user_id)
    conversation = Conversation(
      conversation_id=uuid.uuid4(),
      create_time=time.time(),
      update_time=time.time(),
      messages=[],
    )
    user.conversations.append(conversation)
    return conversation

  def add_message(self, user_id: str, conversation_id: UUID4, role: str, content: str):
    conversation = self.get_converstaion_by_id(user_id, conversation_id)
    message = ChatMessage(
      message_id=uuid.uuid4(),
      conversation_id=conversation_id,
      role=role,
      content=content,
      create_time=time.time(),
    )
    conversation.append_message(message)


conversation_manager = InmemConversationManager()
