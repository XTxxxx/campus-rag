from pydantic import BaseModel, UUID4
from enum import Enum
import time
import uuid
from fastapi import HTTPException
from typing import Optional, Literal, List
from ..utils.llm import llm_chat


class ChatMessage(BaseModel):
  message_id: UUID4  # Generated by uuid
  conversation_id: UUID4
  role: Literal["user", "assistant"]
  content: str
  create_time: float
  sources: Optional[list[dict[str, str]]] = None


class Conversation(BaseModel):
  conversation_id: UUID4  # Generated by uuid
  title: Optional[str] = None
  create_time: float
  update_time: float
  messages: list[ChatMessage]

  def append_message(self, message: ChatMessage):
    self.messages.append(message)
    self.update_time = time.time()

class ConversationView(BaseModel):
  conversation_id: UUID4
  title: Optional[str] = None

class User(BaseModel):
  user_id: str
  conversations: list[Conversation]
  create_time: float


users: list[User] = list()


class SortedBy(str, Enum):
  updated = ("updated_at",)
  created = ("created_at",)
  updated_reverse = ("-updated_at",)
  created_reverse = ("-created_at",)


class Query(BaseModel):
  user_id: str
  conversation_id: Optional[str]
  query: str


class InmemConversationManager:
  def __init__(self):
    self.users = []
    self.conversations = []

  sorted_methods = {
    SortedBy.updated: lambda x: x.update_time,
    SortedBy.created: lambda x: x.create_time,
    SortedBy.updated_reverse: lambda x: -x.update_time,
    SortedBy.created_reverse: lambda x: -x.create_time,
  }

  def get_usr_by_id(self, user_id: str) -> User:
    for user in users:
      if user.user_id == user_id:
        return user
    raise HTTPException(status_code=404, detail="User not found")

  def create_user(self, user_id: str) -> User:
    for u in users:
      if u.user_id == user_id:
        # see http://172.29.4.49/2025seiii-020-team_nailong/rag/-/issues/2
        return u
    new_user = User(
      user_id=user_id,
      create_time=time.time(),
      conversations=[],
    )
    users.append(new_user)
    return new_user

  def get_conversations(
    self,
    user_id: str,
    first_id: int = 0,
    limit: int = 10,
    sorted_by: SortedBy = SortedBy.updated,
  ) -> list[ConversationView]:
    for u in users:
      if u.user_id == user_id:
        sorted_conversations = sorted(
          u.conversations, key=self.sorted_methods[sorted_by]
        )
        selected_conversations = sorted_conversations[first_id : first_id + limit]
        return [ConversationView(conversation_id=conv.conversation_id, title=conv.title) for conv in selected_conversations]
    raise HTTPException(status_code=404, detail="User not found")

  def get_chat_history(self, user_id: str, conversation_id: UUID4) -> list[ChatMessage]:
    for u in users:
      if u.user_id == user_id:
        for c in u.conversations:
          if c.conversation_id == conversation_id:
            return c.messages
        raise HTTPException(status_code=404, detail="Conversation not found")
    raise HTTPException(status_code=404, detail="User not found")

  def get_converstaion_by_id(
    self, user_id: str, conversation_id: UUID4
  ) -> Conversation:
    user = self.get_usr_by_id(user_id)
    for c in user.conversations:
      if str(c.conversation_id) == conversation_id:
        return c
    raise HTTPException(status_code=404, detail="Conversation not found")

  def create_conversation(self, user_id: str):
    user = self.get_usr_by_id(user_id)
    conversation = Conversation(
      conversation_id=uuid.uuid4(),
      create_time=time.time(),
      update_time=time.time(),
      messages=[],
      title=None,
    )
    user.conversations.append(conversation)
    return conversation

  def _extract_title_from_content(self, content: str) -> str:
    """Extract a title from the user's first message using LLM."""
    prompt = [
      {
        "role": "system",
        "content": "You are a helpful assistant. Please generate a concise title for this conversation based on the user's first message. Return only the title without any additional text, quotes or explanations.",
      },
      {"role": "user", "content": f"Generate a title for: {content}"},
    ]

    try:
      title = llm_chat(prompt)
      # Remove any quotes if the LLM added them
      title = title.strip("\"'")
      # Limit length if needed
      if len(title) > 50:
        title = title[:47] + "..."
      return title
    except Exception as e:
      # If title extraction fails, use a fallback
      return content[:20] + "..." if len(content) > 20 else content

  def add_message(self, user_id: str, conversation_id: UUID4, role: str, content: str):
    conversation = self.get_converstaion_by_id(user_id, conversation_id)

    message = ChatMessage(
      message_id=uuid.uuid4(),
      conversation_id=conversation_id,
      role=role,
      content=content,
      create_time=time.time(),
    )
    conversation.append_message(message)

    # If this is the first user message, extract a title
    if (
      role == "user" and len(conversation.messages) == 1 and conversation.title is None
    ):
      conversation.title = self._extract_title_from_content(content)


conversation_manager = InmemConversationManager()
