from pydantic import BaseModel, UUID4
from typing import Optional
from enum import Enum
from sqlmodel import Field, SQLModel, Relationship, JSON, Column, create_engine
import uuid
import time


"""SQLModel is also a Pydantic model, so we can use it directly for our domain objects."""

def uuid_str():
  """Generates a UUID4 string."""
  return str(uuid.uuid4())

class Conversation(SQLModel, table=True):
  conversation_id: str = Field(
    default_factory=uuid_str, primary_key=True, nullable=False
  )  # Generated by uuid
  user_id: str = Field(foreign_key="user.user_id", index=True, nullable=False)
  create_time: float = Field(default_factory=time.time)
  update_time: float = Field(default_factory=time.time)
  title: Optional[str] = None
  # This relationship will load messages. Order by create_time.
  messages: list["ChatMessage"] = Relationship(
    back_populates="conversation",
    sa_relationship_kwargs={"order_by": "ChatMessage.create_time"},
  )
  user: Optional["User"] = Relationship(back_populates="conversations")


class ChatMessage(SQLModel, table=True):
  message_id: str = Field(
    default_factory=uuid_str, primary_key=True, nullable=False
  )
  conversation_id: str = Field(
    foreign_key="conversation.conversation_id", index=True, nullable=False
  )
  conversation: Optional[Conversation] = Relationship(back_populates="messages")
  role: str
  content: str
  create_time: float = Field(default_factory=time.time)
  metainfo: Optional[str] = None


class User(SQLModel, table=True):
  user_id: str = Field(primary_key=True, nullable=False)
  create_time: float = Field(default_factory=time.time)

  conversations: list["Conversation"] = Relationship(
    back_populates="user",
  )


class SortedBy(str, Enum):
  updated = ("updated_at",)
  created = ("created_at",)
  updated_reverse = ("-updated_at",)
  created_reverse = ("-created_at",)


sorted_columns = {
  SortedBy.updated: "update_time",
  SortedBy.created: "create_time",
  SortedBy.updated_reverse: "update_time",
  SortedBy.created_reverse: "create_time",
}


class Query(BaseModel):
  user_id: str
  conversation_id: str
  query: str
