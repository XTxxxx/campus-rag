from pydantic import BaseModel
from typing import Optional, TYPE_CHECKING
from enum import Enum
from sqlmodel import Field, SQLModel, Relationship
import uuid
import time

if TYPE_CHECKING:
  from ..user.po import User


"""SQLModel is also a Pydantic model, so we can use it directly for our domain objects."""


def uuid_str():
  """Generates a UUID4 string."""
  return str(uuid.uuid4())


class Conversation(SQLModel, table=True):
  conversation_id: str = Field(
    default_factory=uuid_str, primary_key=True, nullable=False
  )  # Generated by uuid
  user_id: int = Field(foreign_key="user.id", index=True, nullable=False)
  create_time: float = Field(default_factory=time.time)
  update_time: float = Field(default_factory=time.time)
  title: Optional[str] = None
  # This relationship will load messages. Order by create_time.
  messages: list["ChatMessage"] = Relationship(
    back_populates="conversation",
    sa_relationship_kwargs={"order_by": "ChatMessage.create_time"},
  )
  user: Optional["User"] = Relationship(back_populates="conversations")


class ChatMessage(SQLModel, table=True):
  message_id: str = Field(default_factory=uuid_str, primary_key=True, nullable=False)
  conversation_id: str = Field(
    foreign_key="conversation.conversation_id", index=True, nullable=False
  )
  conversation: Optional[Conversation] = Relationship(back_populates="messages")
  role: str
  content: str
  create_time: float = Field(default_factory=time.time)
  metainfo: Optional[str] = None


class SortedBy(str, Enum):
  updated = ("updated_at",)
  created = ("created_at",)
  updated_reverse = ("-updated_at",)
  created_reverse = ("-created_at",)


sorted_columns = {
  SortedBy.updated: "update_time",
  SortedBy.created: "create_time",
  SortedBy.updated_reverse: "update_time",
  SortedBy.created_reverse: "create_time",
}


class Query(BaseModel):
  conversation_id: str
  query: str


class SearchConfig:
  def __init__(
    self,
    sparse_weight=0.67,
    dense_weight=0.33,
    limit=25,
    offset=0,
    filter_expr=None,
    output_fields=None,
  ):
    if output_fields is None:
      output_fields = ["*"]
    self.sparse_weight = sparse_weight
    self.dense_weight = dense_weight
    self.limit = limit
    self.filter_expr = filter_expr
    self.output_fields = output_fields
    self.offset = offset
