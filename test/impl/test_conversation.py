"""
This test file is generated by Gemini2.5 pro
"""

import pytest
import pytest_asyncio
import uuid
import os
from unittest.mock import AsyncMock

from pydantic import UUID4
from fastapi import HTTPException
from sqlalchemy import create_engine

# Assuming your service file is located at campus_rag.service.chat_service
# Adjust the import path if your file structure is different.
from campus_rag.impl.user.conversation import (
  get_user_by_name,
  create_user,
  create_conversation,
  get_conversation_by_id,
  get_conversations,
  get_chat_history,
  extract_title_from_content,
  add_message_to_conversation,
)
from campus_rag.domain.rag.po import User, Conversation, ChatMessage, SortedBy, SQLModel
from campus_rag.domain.rag.vo import ConversationView
from campus_rag.infra.sqlite import conversation as conversation_db_actual
from sqlalchemy.ext.asyncio import create_async_engine, async_sessionmaker, AsyncSession

# --- Constants for Testing ---
TEST_DB_FILENAME = "test_chat_service_temp.db"
TEST_USER_ID = "test_user_001"
ANOTHER_TEST_USER_ID = "test_user_002"
TEST_DB_FILENAME = "test_temp_app.db"  # 临时数据库文件名


@pytest_asyncio.fixture(scope="function")  # 每个测试函数都会执行一次，确保数据库隔离
async def db_session(tmp_path, monkeypatch):
  """
  为每个测试函数设置一个隔离的内存 SQLite 数据库。
  它会 patch 在 `campus_rag.infra.sqlite.init` 中定义的 `async_engine` 和 `async_session`
  然后创建所有表结构。
  """
  db_file_path = tmp_path / TEST_DB_FILENAME
  sync_engine = create_engine("sqlite:///" + str(db_file_path.resolve()), echo=False)
  test_db_url = f"sqlite+aiosqlite:///{db_file_path.resolve()}"  # 异步SQLite连接字符串
  test_engine = create_async_engine(test_db_url)
  test_session_maker = async_sessionmaker(
    bind=test_engine, class_=AsyncSession, expire_on_commit=False
  )
  monkeypatch.setattr(
    "campus_rag.infra.sqlite.conversation.async_session", test_session_maker
  )
  SQLModel.metadata.create_all(sync_engine)


# --- Mocking Fixture for LLM ---
@pytest.fixture
def mock_llm(mocker):
  """Mocks the llm_chat_async function."""
  # Adjust the path to llm_chat_async according to its actual location
  # relative to where it's called from (i.e., in your chat_service module)
  return mocker.patch(
    "campus_rag.impl.user.conversation.llm_chat_async", new_callable=AsyncMock
  )


# --- Test Cases ---


@pytest.mark.asyncio
async def test_create_user_new():
  user = await create_user(TEST_USER_ID)
  assert user is not None
  assert user.user_id == TEST_USER_ID


@pytest.mark.asyncio
async def test_create_user_existing():
  await create_user(TEST_USER_ID)  # Create first
  user = await create_user(TEST_USER_ID)  # Try to create again
  assert user is not None
  assert user.user_id == TEST_USER_ID
  # Optionally, verify it doesn't create duplicates if your DB layer has constraints
  # This depends on how `conversation_db.insert_user` handles existing users if `find_user_by_id` returns one.
  # The current service logic returns the existing user.


@pytest.mark.asyncio
async def test_get_user_by_id_success():
  await create_user(TEST_USER_ID)
  user = await get_user_by_name(TEST_USER_ID)
  assert user is not None
  assert user.user_id == TEST_USER_ID


@pytest.mark.asyncio
async def test_get_user_by_id_not_found():
  with pytest.raises(HTTPException) as exc_info:
    await get_user_by_name("non_existent_user")
  assert exc_info.value.status_code == 404
  assert "User not found" in exc_info.value.detail


@pytest.mark.asyncio
async def test_create_conversation_success():
  await create_user(TEST_USER_ID)
  conversation_view = await create_conversation(TEST_USER_ID)
  assert conversation_view is not None
  assert isinstance(
    conversation_view.conversation_id, (str, UUID4)
  )  # Check type, UUID4 if it's an actual UUID object
  assert conversation_view.title is None  # Initially no title


@pytest.mark.asyncio
async def test_create_conversation_user_not_found():
  with pytest.raises(HTTPException) as exc_info:
    await create_conversation("unknown_user_for_conv")
  assert exc_info.value.status_code == 404  # From get_user_by_id
  assert "User not found" in exc_info.value.detail


@pytest.mark.asyncio
async def test_get_conversation_by_id_success():
  await create_user(TEST_USER_ID)
  created_conv_view = await create_conversation(TEST_USER_ID)
  conv_id = created_conv_view.conversation_id

  conversation = await get_conversation_by_id(TEST_USER_ID, str(conv_id))
  assert conversation is not None
  assert str(conversation.conversation_id) == str(conv_id)
  assert conversation.user_id == TEST_USER_ID


@pytest.mark.asyncio
async def test_get_conversation_by_id_user_not_found():
  # User doesn't exist, get_user_by_id within get_conversation_by_id should raise
  with pytest.raises(HTTPException) as exc_info:
    await get_conversation_by_id("ghost_user", str(uuid.uuid4()))
  assert exc_info.value.status_code == 404
  assert "User not found" in exc_info.value.detail


@pytest.mark.asyncio
async def test_get_conversation_by_id_not_found():
  await create_user(TEST_USER_ID)  # User exists
  non_existent_conv_id = str(uuid.uuid4())
  with pytest.raises(HTTPException) as exc_info:
    await get_conversation_by_id(TEST_USER_ID, non_existent_conv_id)
  assert exc_info.value.status_code == 404
  assert "Conversation not found" in exc_info.value.detail


@pytest.mark.asyncio
async def test_get_conversations_success(db_session):
  await create_user(TEST_USER_ID)
  conv1_view = await create_conversation(TEST_USER_ID)
  # Simulate some activity to change update times for sorting
  await add_message_to_conversation(
    TEST_USER_ID, str(conv1_view.conversation_id), "Hi", "user"
  )

  conv2_view = await create_conversation(TEST_USER_ID)  # Should be newer

  conversations = await get_conversations(TEST_USER_ID, limit=5)
  assert len(conversations) == 2
  # Default sort is updated_reverse, so conv2 should be first if messages update time
  assert str(conversations[0].conversation_id) == str(conv2_view.conversation_id)
  assert str(conversations[1].conversation_id) == str(conv1_view.conversation_id)


@pytest.mark.asyncio
async def test_get_conversations_pagination(db_session):
  await create_user(TEST_USER_ID)
  for _ in range(3):  # Create 3 conversations
    await create_conversation(TEST_USER_ID)

  # Get first page
  conversations_page1 = await get_conversations(TEST_USER_ID, offset=0, limit=2)
  assert len(conversations_page1) == 2

  # Get second page
  conversations_page2 = await get_conversations(TEST_USER_ID, offset=2, limit=2)
  assert len(conversations_page2) == 1  # Remaining one

  # Ensure IDs are different across pages
  page1_ids = {str(c.conversation_id) for c in conversations_page1}
  page2_ids = {str(c.conversation_id) for c in conversations_page2}
  assert not page1_ids.intersection(page2_ids)


@pytest.mark.asyncio
async def test_get_conversations_user_not_found():
  with pytest.raises(HTTPException) as exc_info:
    await get_conversations("ghost_user_for_list")
  assert exc_info.value.status_code == 404
  assert "User not found" in exc_info.value.detail


@pytest.mark.asyncio
async def test_get_conversations_sorting_created_asc():
  await create_user(TEST_USER_ID)
  conversations = await get_conversations(TEST_USER_ID, sorted_by=SortedBy.created)
  assert (
    len(conversations) >= 2
  )  # Could be more if other tests ran without perfect cleanup
  # This highlights importance of db_setup cleaning everything

  # Assuming the fixture cleans db for each test, we should have exactly 2


@pytest.mark.asyncio
async def test_add_message_and_get_chat_history(mock_llm):
  await create_user(TEST_USER_ID)
  conv_view = await create_conversation(TEST_USER_ID)
  conv_id = str(conv_view.conversation_id)

  # Mock LLM for title generation on first user message
  mock_llm.return_value = "Test Title from LLM"

  msg1_content = "Hello, this is the first user message."
  msg1 = await add_message_to_conversation(TEST_USER_ID, conv_id, msg1_content, "user")
  assert msg1.content == msg1_content
  assert msg1.role == "user"

  # Check if title was updated (need to fetch conversation again)
  updated_conv = await get_conversation_by_id(TEST_USER_ID, conv_id)
  assert updated_conv.title == "Test Title from LLM"

  msg2_content = "This is an assistant response."
  msg2 = await add_message_to_conversation(
    TEST_USER_ID, conv_id, msg2_content, "assistant"
  )
  assert msg2.content == msg2_content
  assert msg2.role == "assistant"

  history = await get_chat_history(TEST_USER_ID, conv_id)
  assert len(history) == 2
  assert history[0].content == msg1_content
  assert history[0].role == "user"
  assert history[1].content == msg2_content
  assert history[1].role == "assistant"


@pytest.mark.asyncio
async def test_add_message_no_title_gen_for_non_user_first_message(mock_llm):
  await create_user(TEST_USER_ID)
  conv_view = await create_conversation(TEST_USER_ID)
  conv_id = str(conv_view.conversation_id)

  await add_message_to_conversation(
    TEST_USER_ID, conv_id, "Assistant starts", "assistant"
  )
  mock_llm.assert_not_called()
  updated_conv = await get_conversation_by_id(TEST_USER_ID, conv_id)
  assert updated_conv.title is None


@pytest.mark.asyncio
async def test_add_message_no_title_gen_if_title_exists(mock_llm):
  await create_user(TEST_USER_ID)
  # Create conversation with a title directly (if possible through DB layer, or simulate)
  # For this test, let's assume a conversation can be created with a title already.
  # If not, we'll first set a title, then add a message.

  # Simulate conversation having a title by manually updating it via conversation_db_actual
  # This is a bit of an integration test hack if service doesn't allow setting title directly.
  raw_conv = await conversation_db_actual.insert_conversation(
    TEST_USER_ID
  )  # Assumes this returns a PO
  raw_conv.title = "Existing Title"
  await conversation_db_actual.update_conversation(
    raw_conv
  )  # Assumes this function exists
  conv_id = str(raw_conv.conversation_id)

  await add_message_to_conversation(
    TEST_USER_ID, conv_id, "User message to conv with title", "user"
  )
  mock_llm.assert_not_called()  # Should not try to generate title
  updated_conv = await get_conversation_by_id(TEST_USER_ID, conv_id)
  assert updated_conv.title == "Existing Title"


@pytest.mark.asyncio
async def test_get_chat_history_empty():
  await create_user(TEST_USER_ID)
  conv_view = await create_conversation(TEST_USER_ID)
  conv_id = str(conv_view.conversation_id)

  history = await get_chat_history(TEST_USER_ID, conv_id)
  assert len(history) == 0


@pytest.mark.asyncio
async def test_get_chat_history_conversation_not_found():
  await create_user(TEST_USER_ID)
  with pytest.raises(HTTPException) as exc_info:
    await get_chat_history(TEST_USER_ID, str(uuid.uuid4()))
  assert exc_info.value.status_code == 404
  assert "Conversation not found" in exc_info.value.detail
